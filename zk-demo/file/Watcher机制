ZooKeeper的Watch机制
ZooKeeper允许客户端向服务端注册一个Watcher监听，当服务端的一些指定事件发生后触发这个Watcher，那么会向指定客户端发送一个事件通知来实现分布式的通知功能
ZooKeeper的Watcher机制主要包括客户端线程、客户端WatcherManager和ZooKeeper服务器三个部分。客户端再向ZooKeeper服务器注册Watcher的同时，会将Watcher对象存储在客户端的WatchManager中。当ZooKeeper服务器触发Watcher事件后，会向客户端发送通知，客户端线程从WatchManager中取出对应的Watcher对象来执行回调逻辑。

Watcher接口定义
Watcher接口定义了一个方法process
abstract public void process(WatchedEvent event);
WatchedEvent：定义了通知状态、事件类型和对应的节点路径（path）


Watcher接口中也定义了两个枚举：KeeperState和EventType，分别表示通知状态和事件类型
KeeperState（通知状态）包含如下几种：
SyncConnected：客户端与服务器处于连接状态，对应的事件可以包含（NodeCreated、NodeDeleted、NodeDataChanged、NodeChildrenChanged）
Disconnected：客户端与服务器连接断开
AuthFailed：权限验证失败
Expired：超时
EventType（事件类型）包含如下几种：
NodeCreated：节点创建
NodeDeleted：节点删除
NodeDataChanged：节点数据修改
NodeChildrenChanged：子节点修改

ZooKeeper的Watcher机制，可以概况为	以下3个过程：
1-客户端注册Watcher
2-服务端处理Watcher
3-客户端回调Watcher

客户端注册Watcher
创建ZooKeeper对象，获取获取数据、判断节点是否存在的时候可以传入Watcher对象，用来注册Watcher监听
如下三个方法：
public ZooKeeper(String connectString, int sessionTimeout, Watcher watcher) throws IOException;
public byte[] getData(String path, boolean watch, Stat stat)  throws KeeperException, InterruptedException;
步骤如下：
0-判断是否传入Watcher对象，以下步骤假设传入Watcher对象
1-将Watcher对象封装在WatchRegistration对象中，保存数据节点路径和Watcher对应关系
2-将WatchRegistration对象封装在Packet中，然后放入发送队列outgoingQueue中
3-客户端发送outgoingQueue中Packet对象到服务器上
4-客户端启动的SendThread中的readResponse方法负责接收服务端的响应，调用finishPacket方法从响应中取出对应的Watcher并注册到ZKWatcherManager中

服务端处理Watcher
服务端收到客户端发送的带有Watcher的请求后，关于Watcher部分处理步骤如下：
1-FinalRequestProcessor的processRequest()方法判断是否带有Watcher，以下步骤假设带有
2-取出Watcher对象，存储在WatcherManager中，以两个维度进行存储，
a-watchTable(数据结构Map<String,Set<Watcher>>，key是节点路径，value是路径对应的注册的Watcher)存入Watcher
b-watch2Paths(数据结构Map<Watcher,Set<String>>，key是Watcher对象，value是这个Watcher对应监听的节点路径)
3-当有Watcher监听事件被客户端提交时，DataTree数据有任何变化时，就会调用对应事件的WatcherManager的triggerWatch方法，具体步骤如下
3.1-封装WatchedEvent对象，将通知状态、事件类型及节点路径封装成WatchedEvent
3.2-取出watchTable/watch2Paths中的Watcher对象，然后移除Watcher
3.3-遍历取出的Watcher集合，调用Watcher的process方法，在NIOServerCnxn的process方法中，主要完成如下步骤
3.3.1-将ReplyHeader的xid设置为-1，标识这是一个Watcher响应
3.3.2-将WatchedEvent包装成WatcherEvent
3.3.3-向客户端发送WatcherEvent对象，通知客户端

客户端处理Watcher
在服务端将WatcherEvent发送给客户端后，客户端的SendThread线程的readResponse方法来处理
在readReponse方法中获取响应的xid，如果是-1，表示这是一个Watcher响应，处理步骤如下：
1-反序列化，将响应中的字节流反序列化为WatcherEvent对象
2-处理chrootPath
3-将WatcherEvent包装成WatchedEvent
4-将WatchedEvent对象发送给EventThread线程进行处理，进行对应的客户端Watcher的回调，回调完成后删除Watcher对象，说明客户端上的Watcher也是一次性的

Watcher特性
1-一次性：不论是ZooKeeper服务端还是客户端，Watcher都是一次性的，一旦一个Watcher被触发后，服务端和客户端都是移除对应的Watcher
2-客户端串行执行：客户端回调是一个串行同步的过程，保证了Watcher的顺序性
3-轻量：Watcher只会告知通知状态、事件类型和节点路径